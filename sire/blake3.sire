/+  apply
/+  bool
/+  prim
/+  either
/+  eql
/+  list
/+  list_core
/+  maybe
/+  nat
/+  prim
/+  row
/+  tab
/+  w32
/+  tar ("*")
/+  hax ("#")
/+  com ("," ",,")


;;;;;;;;;;;;;;;;;
;; Definitions ;;
;;;;;;;;;;;;;;;;;

= (gulf f t) | gen (sub inc-t f) add-f

; Constants
b3OutLen=32
b3KeyLen=32
b3BlockLen=64
b3ChunkLen=1024
b3ChunkStart=(lsh 1 0)
b3ChunkEnd=(lsh 1 1)
b3Parent=(lsh 1 2)
b3Root=(lsh 1 3)
b3KeyedHash=(lsh 1 4)
b3DeriveKeyContext=(lsh 1 5)
b3DeriveKeyMaterial=(lsh 1 6)

= b3Iv
,, 0x6A09E667
,, 0xbb67ae85
,, 0x3C6ef372
,, 0xA54ff53a
,, 0x510E527F
,, 0x9B05688C
,, 0x1F83D9ab
,, 0x5be0cd19

= b3MsgPermutation
, 2 6 3 10 7 0 4 13 1 11 12 5 9 14 15 8

= (b3G S a b c d mx my)
@ S | put S a | add32 (add32 get-S-a get-S-b) mx
@ S | put S d | ror32 (xor32 get-S-d get-S-a) 16
@ S | put S c | add32 get-S-c get-S-d
@ S | put S b | ror32 (xor32 get-S-b get-S-c) 12
@ S | put S a | add32 (add32 get-S-a get-S-b) my
@ S | put S d | ror32 (xor32 get-S-d get-S-a) 8
@ S | put S c | add32 get-S-c get-S-d
@ S | put S b | ror32 (xor32 get-S-b get-S-c) 7
S

= (b3Round st m)
; Mix the columns
@ st | b3G st 0 4  8 12 get-m-0 get-m-1
@ st | b3G st 1 5  9 13 get-m-2 get-m-3
@ st | b3G st 2 6 10 14 get-m-4 get-m-5
@ st | b3G st 3 7 11 15 get-m-6 get-m-7
;
; Mix the diagonals
@ st | b3G st 0 5 10 15 get-m-8  get-m-9
@ st | b3G st 1 6 11 12 get-m-10 get-m-11
@ st | b3G st 2 7  8 13 get-m-12 get-m-13
@ st | b3G st 3 4  9 14 get-m-14 get-m-15
st

= (b3Permute m)
| gen 16
& i
| get m
| get b3MsgPermutation i

= (u8weld x y)
| add x (lsh y 8)

; welds up to four u8.
= (u32weld v)
| ifNot (aeq len-v 4)
    | die "u32weld requires 4 bytes"
| u8weld get-v-0
| u8weld get-v-1
| u8weld get-v-2
         get-v-3

; Row W8 > Row W32
= (bytesToWords bv)
| if (mod len-bv 4)
    | die "byte-row length not a multiple of 4"
@ wid (div len-bv 4)
. 0 0 (mkRow wid)
? (loop i j acc)
| if (eql j wid) acc
@ next (add i 4)
| loop next inc-j
| acc | u32weld | slice bv i next

; Row W8 > Row W32
= (bytesToWords bv)
| if (mod len-bv 4)
    | die "byte-row length not a multiple of 4"
@ wid (div len-bv 4)
| gen wid
& j
@ i (mul j 4)
| u32weld (slice bv i (add i 4))

; breaks a nat that represents a word into
; its little-endian component bytes
(wordToBytes a)=(gen 4 i&(dis 0xff (rsh a (mul 8 i))))

; Little Endian Byte order
; (Row W32 > Row W8)
= (wordsToBytes wv)
| catMap wordToBytes wv

; > (V8 u32, V16 u32, u64, u32, u32)
; > V16 u32
= (b3Compress tupl)
*     , chainingValue ;; TODO Support `,,` in patterns.
        blockWords
        counter
        blockLen
        flags
   | tupl
@ st ,, (get chainingValue 0)
     ,, (get chainingValue 1)
     ,, (get chainingValue 2)
     ,, (get chainingValue 3)
     ,, (get chainingValue 4)
     ,, (get chainingValue 5)
     ,, (get chainingValue 6)
     ,, (get chainingValue 7)
     ,, (get b3Iv 0)
     ,, (get b3Iv 1)
     ,, (get b3Iv 2)
     ,, (get b3Iv 3)
     ,, (chop32 counter)
     ,, (chop32 rsh-counter-32)
     ,, blockLen
     ,, flags
@ block blockWords
@ st    | b3Round st block         ;;; round 1
@ block | b3Permute block
@ st    | b3Round st block         ;;; round 2
@ block | b3Permute block
@ st    | b3Round st block         ;;; round 3
@ block | b3Permute block
@ st    | b3Round st block         ;;; round 4
@ block | b3Permute block
@ st    | b3Round st block         ;;; round 5
@ block | b3Permute block
@ st    | b3Round st block         ;;; round 6
@ block | b3Permute block
@ st    | b3Round st block         ;;; round 7
;
. 0 st
? (loop i st)
| if (eql i 8)
   st
@ st | put st i
     | xor32 (get st (add i 8))
     | get st i
@ st | put st (add i 8)
     | xor32 (get st (add i 8))
     | get chainingValue i
| loop inc-i st

(first8words v)=(slice v 0 8)

= | b3OutputNew
    inChain
    blockWords
    counter
    len
    flags
(inChain, blockWords, counter, len, flags)

(b3OutputGetInputChainingValue o)=(get o 0)
(b3OutputGetBlockWords o)=(get o 1)
(b3OutputGetCounter o)=(get o 2)
(b3OutputGetBlockLen o)=(get o 3)
(b3OutputGetFlags o)=(get o 4)

= (b3OutputChainingValue output)
| first8words
| b3Compress output

; Modification to the previous way the rust
; version worked: the rust version took a
; buffer called outSlice, which got filled
; instead of returning a buffer of the
; right size.
= (b3OutputRootOutputBytes o outSize)
@ outChunkLen
    | mul 2 b3OutLen
@ wid
    | div (roundUp outSize outChunkLen)
          outChunkLen
| cat
. 0 outSize (mkRow wid)
? (loop outputBlockCounter remBytes acc)
| if (eql outputBlockCounter wid) acc
@ words | b3Compress
        ,, b3OutputGetInputChainingValue o
        ,, b3OutputGetBlockWords o
        ,, outputBlockCounter
        ,, b3OutputGetBlockLen o
        ,, or32 b3OutputGetFlags-o b3Root
@ need | min outChunkLen remBytes
@ segm | take need
       | wordsToBytes words
| loop
   (inc outputBlockCounter)
   (sub remBytes need)
   (acc segm)

; = ChunkState
; , chainingVal
; , chunkCounter
; , block
; , blockLen
; , blocksCompressed
; , flags

(b3ChunkstGetChainingVal c)=(get c 0)
(b3ChunkstGetChunkCounter c)=(get c 1)
(b3ChunkstGetBlock c)=(get c 2)
(b3ChunkstGetBlockLen c)=(get c 3)
(b3ChunkstGetBlocksCompressed c)=(get c 4)
(b3ChunkstGetFlags c)=(get c 5)
(b3ChunkstPutChainingVal c)=(put c 0)
(b3ChunkstPutChunkCounter c)=(put c 1)
(b3ChunkstPutBlock c)=(put c 2)
(b3ChunkstPutBlockLen c)=(put c 3)
(b3ChunkstPutBlocksCompressed c)=(put c 4)
(b3ChunkstPutFlags c)=(put c 5)

= (b3ChunkstNew keyWords chunkCounter flags)
,, keyWords
,, chunkCounter
,, rep 0 b3BlockLen
,, 0
,, 0
,, flags

= (b3ChunkstLen c)
| add (b3ChunkstGetBlockLen c)
| mul b3BlockLen
| b3ChunkstGetBlocksCompressed c

= (b3ChunkstStartFlag c)
| if (eql b3ChunkstGetBlocksCompressed-c 0)
     b3ChunkStart
     0

; /(Chunk > Row u8 > Chunk)
= (b3ChunkstUpdate c input)
| if (eql len-input 0) c
@ c | if (neq b3BlockLen b3ChunkstGetBlockLen-c)
      | c
    ; If the block buffer is full, compress
    ; it and clear it.
    @ blockWords
        | bytesToWords
        | b3ChunkstGetBlock c
    @ c | b3ChunkstPutChainingVal c
        | first8words
        | b3Compress
        ,, b3ChunkstGetChainingVal c
        ,, blockWords
        ,, b3ChunkstGetChunkCounter c
        ,, b3BlockLen
        ,, or32 b3ChunkstGetFlags-c
                b3ChunkstStartFlag-c
    @ c | b3ChunkstPutBlocksCompressed c
        | inc b3ChunkstGetBlocksCompressed-c
    @ c | b3ChunkstPutBlock c
        | rep 0 b3BlockLen
    @ c | b3ChunkstPutBlockLen c 0
    c
@ want | sub b3BlockLen b3ChunkstGetBlockLen-c
@ need | min want len-input
@ c | b3ChunkstPutBlock c
    | weld (take need input)
    | drop need b3ChunkstGetBlock-c
@ c | b3ChunkstPutBlockLen c
    | add b3ChunkstGetBlockLen-c need
| b3ChunkstUpdate c drop-need-input

= (b3ChunkstOutput c)
@ blockWords
   | bytesToWords b3ChunkstGetBlock-c
| b3OutputNew
   b3ChunkstGetChainingVal-c
   blockWords
   b3ChunkstGetChunkCounter-c
   b3ChunkstGetBlockLen-c
| or32
   (or32 b3ChunkstGetFlags-c b3ChunkstStartFlag-c)
   b3ChunkEnd

= | b3ParentOutput
    lChildCv
    rChildCv
    keyWords
    flags
@ blockWords
    | weld (take 8 lChildCv)
           (take 8 rChildCv)
| b3OutputNew
   keyWords
   blockWords
   0
   b3BlockLen
   (or32 b3Parent flags)

= (b3ParentCv lChildCv rChildCv keyWords flags)
| b3OutputChainingValue
| b3ParentOutput
   lChildCv
   rChildCv
   keyWords
   flags

; (Modifying cvStack,cvStackLen to just use
; a list in this port.)
;
; = Hasher
; , chunkState/ChunkState
; , keyWords/(u32*8)
; , cvStack/(List)
; , flags

(b3HasherGetChunkst h)=(get h 0)
(b3HasherGetKeyWords h)=(get h 1)
(b3HasherGetCvStack h)=(get h 2)
(b3HasherGetFlags h)=(get h 3)

(b3HasherPutChunkst h st)=(put h 0 st)
(b3HasherPutCvStack h cv)=(put h 2 cv)

= (b3HasherNewInternal keyWords flags)
| ifNot (eql 8 len-keyWords)
    | die "Incorrect length of keyWords"
,, b3ChunkstNew keyWords 0 flags
,, keyWords
,, NIL
,, flags

= b3HasherNew
| b3HasherNewInternal b3Iv 0

; Punting: newKeyed, newDeriveKey.

; (h > cv > h)
= (b3HasherPushStack h cv)
@ st ! CONS cv (b3HasherGetCvStack h)
| b3HasherPutCvStack h st

; (hashState > [cv hashState])
= (b3HasherPopStack hSt)
! listCase (b3HasherGetCvStack hSt)
   | die """Trying to pop empty stack
& (! top res)
| (top, b3HasherPutCvStack hSt res)

; "Section 5.1.2 of the blake3 spec explains
; this algorithm in more detail."
;
; Returns h
= | b3HasherAddChunkChainingValue
    h
    newCv
    totalChunks
. h newCv totalChunks
? (go h newCv totalChunks)
| ifNot (and32 totalChunks 1)
    * [leftCv h]
        | b3HasherPopStack h
    @ newCv
        | b3ParentCv
          leftCv
          newCv
          b3HasherGetKeyWords-h
          b3HasherGetFlags-h
    @ totalChunks
        | rsh totalChunks 1
    | go h newCv totalChunks
| b3HasherPushStack h newCv

= (b3HasherUpdate h input)
@ final
    & (h input)
    @ want  | sub b3ChunkLen
            | b3ChunkstLen
            | b3HasherGetChunkst h
    @ need  | min want (len input)
    @ temp  | b3ChunkstUpdate
              (b3HasherGetChunkst h)
              (take need input)
    @ h     | b3HasherPutChunkst h temp
    @ input | drop need input
    | b3HasherUpdate h input
| ifNot (len input) h
| if    | neq b3ChunkLen
        | b3ChunkstLen
        | b3HasherGetChunkst h
    | final h input
@ chunkCv
    | b3OutputChainingValue
    | b3ChunkstOutput
    | b3HasherGetChunkst h
@ totalChunks
    | inc
    | b3ChunkstGetChunkCounter
    | h.b3HasherGetChunkst
@ h | b3HasherAddChunkChainingValue
      h
      chunkCv
      totalChunks
@ h | h.b3HasherPutChunkst
    | b3ChunkstNew
      h.b3HasherGetKeyWords
      totalChunks
      h.b3HasherGetFlags
| final h input

; (Hasher > Nat > Row u8)
= (b3Finalize h outHashSize)
@ out (b3ChunkstOutput h.b3HasherGetChunkst)
. out h.b3HasherGetCvStack
? (go output stack)
! listCase stack
  | b3OutputRootOutputBytes output outHashSize
& (top res)
@ output
   | b3ParentOutput
     top
     output.b3OutputChainingValue
     h.b3HasherGetKeyWords
     h.b3HasherGetFlags
| go output res

; One-function convenience method that
; handles entire operation for one row.
(blake3 v)=(b3Finalize b3HasherUpdate-b3HasherNew-v 32)


;;;;;;;;;;;
;; Tests ;;
;;;;;;;;;;;

/+  bar ("#x" barCat bytesBar)
/+  cord (cordToRow)

?? eql | barCat
       ,, x#7470ea5654831e01ffc04ee0e43a32fb
       ,, x#90227162dc0faaa14f9627d8f5c718f7
   (| bytesBar | blake3 | cordToRow "fdsafdsa")

;;;;;;;;;;;;;
;; Exports ;;
;;;;;;;;;;;;;

^-^ blake3
