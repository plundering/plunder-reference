/+  apply      (idx)
/+  bool       (if ifNot and or not true)
/+  prim       (apply supply)
/+  eql        (eql)
/+  list_core  (CONS NIL listCase listHead listSafeHead listUnsafeHead)
/+  nat        (inc dec mod div add lth)
/+  prim       (seq isNat)
/+  row        (foldl foldr)
/+  row        (cow ",")

= (listFoldl f z l)
! listCase l z
& (x xs)
@ fzx (f z x)
| seq fzx
| listFoldl f fzx xs

= (listFoldr f z l)
! listCase l z
& (x xs)
| f x (listFoldr f z xs)

= (listMap f l)
! listCase l NIL
& (x xs)
! CONS f-x listMap-f-xs

(listTurn l f)=(listMap f l)

= (listLen l)           | listFoldr (x acc & inc acc) 0 l
= (listSum l)           | listFoldr add 0 l
= (listToRow l)         | listFoldr supply cow-(listLen l) l
= (listToRowReversed l) | listFoldl apply cow-(listLen l) l
= (listFromRow v)       | foldr CONS NIL v
= (listAnd v)           | listFoldr and true v
= (listOr v)            | listFoldr or 0 v
= (listSum v)           | listFoldr add 0 v
= (listAll f v)         | listAnd listMap-f-v
= (listAny f v)         | listOr listMap-f-v
= (listHas e xs)        | listAny eql-e xs
= (listEnumFrom n)      ! CONS n (listEnumFrom inc-n)

= (listWeld a b)
! listCase a b
& (x xs)
! CONS x (listWeld xs b)

; Lis (Lis a) > Lis a
= (listCat ls)
! listCase ls NIL
& (x xs)
| listWeld x
| listCat xs

= (listTake num lis)
| ifNot num NIL
! listCase lis NIL
& (x xs)
! CONS x
| listTake dec-num xs

= (listDrop num lis)
| ifNot num lis
! listCase lis NIL
| (x xs & listDrop dec-num xs)

; TODO This does not belong here
; Convert a nat into a list of digits.
; TODO: Use `until`?
= (listDigits num)
| ifNot num (CONS %0 0)
. num NIL
? (loop mor acc)
| seq acc
| ifNot mor acc
@ char (add (mod mor 10) "0")
@ left (div mor 10)
| loop left (! CONS char acc)

; Convert a nat into a row of digits.
= (digits num) (listToRow listDigits-num)

= (listZipWith f al bl)
! listCase al NIL
& (a as)
! listCase bl NIL
& (b bs)
! CONS f-a-b
  (listZipWith f as bs)

(listZip a b)=(listZipWith (0 0 3 0) b a)

?? @ expect  ! CONS [3 4] ! CONS [4 5] NIL
   @ compute | listZip listFromRow-[3 4] listFromRow-[4 5]
   | eql expect compute

= (listFilter f lis)
! listCase lis NIL
& (x xs)
| if f-x (! CONS x listFilter-f-xs)
| listFilter f xs

(listNull xs)=(isNat xs)

;; TODO If I implement inline lambdas, can I use a `list` destructuring
;;      function to generate this same code?  That would be useful
;;      because I want the pattern matching syntax to be a macro, but
;;      this part of the code probably comes before the macro
;;      implementation.

= (listMinimumOn f a bs)
! listCase bs a
& (x xs)
| listMinimumOn f
   | if (lth f-x f-a) x a
| xs

= (listSortOn f lis)
! listCase lis NIL
& (x xs)
@ fst | listMinimumOn f x xs
@ fky | f fst
@ rst | listSortOn f
      | listFilter x&(not (eql fky f-x))
      | lis
! CONS fst rst

; TODO This is out of place!
= (sortOn f row)
| listToRow
| listSortOn f
| listFromRow row

^-^ NIL CONS
^-^ listCase
^-^ listMap listTurn
^-^ listHead listSafeHead listUnsafeHead
^-^
^-^ listFoldl listFoldr listMap listTurn listLen listSum listToRow
^-^ listToRowReversed listFromRow listAnd listOr listSum listAll listAny
^-^ listHas listEnumFrom listWeld listCat listTake listDrop listDigits
^-^ digits listZipWith listZip listFilter listNull listMinimumOn listSortOn
^-^ sortOn
