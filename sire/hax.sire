/+  prim   (die)
/+  bool   (if ifNot)
/+  nat    (lth)
/+  eql    (eql)
/+  row    (idx len drop ",")
/+  either (LEFT RIGHT)
/+  cord   (cordWeld)
/+  sire   (cnsE)
/+  rex    (HEIR rexGetWord)
/+  tab    (hasKey look)

;;; TODO Handle cases where `x` is not a valid identifier (use one of
;;; these forms: ($"asdf" $234).
= (showSymbol x)
| x

= ("#" envr next kids heir)
@ rex
    | HEIR "#" kids heir
| if (lth len-kids 1)
    | LEFT [rex "# Macros needs at least on kid"]
! rexGetWord (idx 0 kids)
    | LEFT [rex "First parameter to # must be a bare-word"]
& name
@ key (cordWeld "#" name)
| ifNot (hasKey key envr)
   LEFT-[rex (cordWeld "Undefined Symbol: " showSymbol-key)]
@ fun (look envr key)
| fun envr next (drop 1 kids) heir
    ;;;
    ;;; TODO Really need to change the macro interface so that
    ;;; macros simple receive the whole rexpression they matched on.
    ;;;

= ("#foo" envr next kids heir)
| RIGHT [0 (cnsE %[=next =kids =heir])]

(foo#bar)zaz

?? eql (foo#bar)zaz
   %% =heir [1 %zaz]
   %% =kids [[1 %bar]]
   %% =next 0

;;;;;;;;;;;;;
;; Exports ;;
;;;;;;;;;;;;;

^-^ "#"
