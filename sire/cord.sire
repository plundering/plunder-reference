/+  nat   (lte gte aeq)
/+  nat   (add mul mod lsh met rsh dis)
/+  nat   (roundUp takeBits)
/+  nat   (inc div)
/+  bool  (ifNot and or not)
/+  list  (CONS NIL listFoldl listToRow)
/+  row   (foldl foldr ",")

;; TODO Maybe this should live in `char`?
(isDigit c)=(and (gte c '0') (lte c '9'))
(isUpper c)=(and (gte c 'A') (lte c 'Z'))
(isLower c)=(and (gte c 'a') (lte c 'z'))
(isAlpha c)=(or isUpper-c isLower-c)

(cordWeld x y)=(| add x | lsh y | roundUp met-x 8)
(cordCat vs)=(foldl cordWeld 0 vs)
(cordTake n c)=(takeBits (mul 8 n) c)
(cordDrop n c)=(rsh c (mul 8 n))

= (cordToList s)
| ifNot s NIL
| CONS (mod s 256)
| cordToList (div s 256)

(cordFromList cs)=(listFoldl cordWeld 0 cs)

(cordToRow str)=(listToRow cordToList-str)
(cordFromRow cs)=(cordCat cs)


;;;;;;;;;;;
;; Tests ;;
;;;;;;;;;;;

/+  eql

?? aeq "fdsa" (cordWeld "" "fdsa")
?? aeq "fdsa" (cordWeld "f" "dsa")
?? aeq "fdsa" (cordWeld "fd" "sa")

?? eql [%f]    (cordToRow "f")
?? eql [255]   (cordToRow 255)
?? eql [%f %d] (cordToRow "fd")

;;;  isDigit isUpper isLower isAlpha
;;;  cordWeld cordCat
;;;  cordToRow cordImplode
