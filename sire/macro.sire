/+  prim       (apply)
/+  bool       (if)
/+  eql        (eql neq)
/+  either     (LEFT RIGHT eitherCase eitherOpen eitherMap)
/+  apply      (idx len)
/+  row        (weld switch zipWith map turn rowApply ",")
/+  list       (NIL CONS listCase listToRowReversed listFromRow digits)
/+  tab        (tabToPairs)
/+  cord       (cordWeld cordCat)

/+  rex        (FAIL NODE HEIR WORD CORD PAGE EBED)
/+  rex        (rexCase rexGetNode rexGetWord rexGetText)
/+  rex        (isWord)
/+  rex        (mkHeir mergeHeir rexGetNodeFolded)
/+  rex        ("`")

/+  sire       (eitherRowSequence eitherRowTraverse)


;;;;;;;;;;;;;;;;;;;;;
;; Macro Utilities ;;
;;;;;;;;;;;;;;;;;;;;;

(showNat n)=(cordCat digits-n)

= (gensymE n)  | WORD (cordWeld "_g" showNat-n)

= (vecE vals)
| NODE ',' vals

; (Tab Rex > Rex)
= (tabE tab)
@ kvs | turn tabToPairs-tab
      & kv
      @ k idx-0-kv
      @ v idx-1-kv
      | NODE '=' [(WORD showNat-k) v]
| NODE '%' [vecE-kvs]


;;;;;;;;;;;;;;;;;;;;;;
;; Macro Generators ;;
;;;;;;;;;;;;;;;;;;;;;;

= (simpleMacro rune argParsers fun env nex xs mK)
@ rex (mkHeir rune xs mK)
@ arg mergeHeir-xs-mK
| if  | neq len-argParsers len-arg
   | LEFT , rex | cordCat
                , "Expecting "
                  (showNat len-argParsers)
                  " parameters"
! eitherOpen
   | eitherRowSequence
   | zipWith apply argParsers arg
& params
! eitherOpen (rowApply fun params)
| (res & RIGHT [0 res])

= (gensymMacro rune argParsers fun env nex xs mK)
@ rex (mkHeir rune xs mK)
@ arg mergeHeir-xs-mK
| if (neq len-argParsers len-arg)
   | LEFT , rex | cordCat
                , "Expecting "
                  (showNat len-argParsers)
                  " parameters"
! eitherOpen
   | eitherRowSequence
   | zipWith apply argParsers arg
& params
; trk [%OPENED %[=params]]
| rowApply fun-nex params

^-^ simpleMacro gensymMacro
^-^ eitherRowSequence eitherRowTraverse
^-^ vecE tabE gensymE
^-^ isWord
