Finish up `stg` Changes
=======================

-   Build cleanly
-   Tests run

-   Tab macro? (Will also require handling %x).
-   Macro expansion passes whole `Rex` node to expander.
-   Use `rex` datajet for macros.

-   Mandelbrot uses bars?
-   Mandelbrot generates correct output?

-   Optimize vector construction
-   Optimize tab construction
-   Optimize switch calls.
-   Optimize tabSwitch calls.

-   Implement `pinCat` and `pinFlat`.
-   Jar uses `pinFlat`?
-   Optimize jar impl (don't duplicate work) and use to validate jet hashes?


Sire
====

-   Sire uses zero-arity laws to evaluate top-level expressions (instead
    of one-argument laws with a dummy argument)

-   Build a macro for Tabs and Rows (And also for Cabs and Cows)

    This will finally let use remove these from Sire itself.

-   I used letE somewhere where I intended to use recE (recE is now `@@`
    instead of `~`).  Fix.  Oh yeah, this was in `#knot`

-   More expressive `(: (bind) <- fdsafdsa)`.

    -   `<-` should not do inlining (uses the `-` rune)
    -   `<!` should do inlining     (uses the `!` rune)
    -   `<|` should also not do inlining (uses the `|` rune).
    -   `<,` should work too (uses the `,` rune).

        This last example is pointless, but why not just support this
        in general?

    The no-inline pattern is useful for things like `turn`.

        : item <- list_turn
                | list_gen (sub inc-t f) add-f
        | inc | mul item

-   TODO consider bringing back the `@ (f x) body cont` syntax?

-   TODO Differentiate between empty import list and no import list.

    `/+ foo` should not do the same things as `/+ foo ()`.

-   TODO Move all logic from tests/*.sire into `sire/*.sire` modules.
    Replace test routines with code that merely imports.

-   TODO Assertions should print evaluated arguments

    `?? eql (add 1 2) (inc 9)` should print `?? eql 3 10` to show what failed.

    Right now it just prints `1!=0` and `?? eql (add 1 2) (inc 9)`.

-   Carefully think through and document how inlining works.

    An `Inliner` is a function, whose local bindings are resolved (Refr),
    but will need to be re-keyed during inlining.  Whose global bindings
    are resolved directly to plunder values.

    And Inliner is a fully parsed and name-resolved expression, all
    macros have been expanded.

    However, no transformations have been performed.  No lambdas have
    been lifted.  No LETs have been removed.

    In particular, "inline application" and "static application" nodes
    are still in place.  Inlining can expose opportunities for further
    inlining (and static application) there were not possible before
    inlining.

    Somehow, on import, we want to export a table of "Globals".

-   TODO: Optimize lets AGAIN after inlining

    Inlining can remove references to let-bindings, and we don't want
    to generate code for let-bindings that are not used.

-   TODO All command runes should be two-characters (except =)

    Use `/=`, `*=`, etc.  Having overlapping runes between commands and
    expressions is very confusing because commands are a superset of
    expressions (raw expressions interpreted as PRINT).

    -   TODO Give `XDUMPY` a two-char rune.
    -   TODO Give `XALIAS`, `/` a two-char rune.

-   TODO Cleanup SireExe.

Loot
====

- TODO Add QuickCheck tests for Loot (Val -> Text -> Val).

- Go further and have every generated binder name in an output block get
  a unique name:

    For example, in the following code, we bind `j k l` many times:

        = (jam a b)
        @ c
           ? (jamCore d)
           @ e ((j k l & j (R3:0 k l)) jamCore)
           @ f ((j k l m n & j (R5:2 k l m n)) jamCore)
           @ g ((j k l m & j (R4:3 k l m)) jamCore)

    Large dis-assembled functions are noisy enough without the re-use of
    variables names.

    Instead, we should have:

        = (jam a b)
        @ c
           ? (jamCore d)
           @ e (h i j & h (R3:0 i j))-jamCore
           @ f (k l m n o & k (R5:2 l m n o))-jamCore
           @ g (p q r s & p (R4:3 q r s))-jamCore


-   Consider re-using variable names when a variable is passed into
    directly to a lambda.

    This makes things clearer in the common case of lambda-lifting.

    `(a b c & z)-a` instead of `(b c d & x)-a`


Rex
===

-   Rex runes should be indentation sensitive along the right side (not left)

    These, for example, are aligned:

        %%% x
          | y
         ^^ z

    Instead of the current:

        %%% x
        | y
        ^^ z

    TODO: Then how would bare words need to be aligned?

        %%% x
          | y
         ^^ z
          hello

        Tempting to say that you just shouldn't do this.  (You shouldn't).

        However, the Rex data structure does allow `(&& x)hello` and
        the tall form of that needs to be printable somehow.

            && x
             hello

    TODO What about pages?

        Maybe you know, like...

              | x
            """ Do you mean like this?

        Yes, I think it should work like that.

    TODO Does that imply that the space after ''' should be mandatory?

        No.  It looks weird, but it's okay.

                | x
              """y

-   TODO: should name-pages juxtaposition be accepted?

    This used to be supported, but it was removed when special syntax
    for namePage and nameCord were removed.

        X""" This is a
         """ Test.

    However, this is a perfectly coherent concept:

    - It might make the grammar more complex.

    - It breaks the usual assumption that the child of a wide-mode
      objects is in wide-mode.

        Or, to put that another way: `X""" x` can be printed only if it
        isn't in a nested construct.  It's a pretty specific edge-case.

    Overall, I think this syntax looks nice but may not be worth the
    complexity.

    If we were to use a rune instead.

    Actually, another data-point here is that:

        x&""" hi
        $"""x y z

    Are also pretty nice.  Should we allow pages in any non-nested
    context?

    This is actually not hard in the lexer, just accept pages anywhere.
    They will automatically fail to parse in any nested context.

    Main concern is that it's complicated to print correctly.


Plunder
=======

-   Jet mkPin, isPin, etc.
-   Lazy loading?
-   TODO Generic set (different from cab)
-   TODO Generic map (different from tab)
-   Implement `pad_flat`.

    We should also use a jetted `pad_flat` operation that takes a
    rose-tree of Pads and concatenates all.  Build this for Bar as well.

        ??  eql  p#0012300  padFlat-[p#0 [p#0 p#12] p#3 p#00]


Mandelbrot
==========

- TODO Get Mandelbrot code running correctly.


Bootstrapping
=============

Understand the event log implementation. If it isn't fully working
yet, see if I can help him with that.


Jar
---

-   TODO Jar does a state-monad traversal through the dependency tree,
    explicitly keeping track of which hashes are assigned to which pins.
    No more repeatedly processing the same pins.

Jam Optimisations:

-   Rewrite `Jam` to produce a Pad (using `pad_flat`).

-   Rewrite `blake3` to produce a Bar (and to use a bar internally)

    Will need operations like `bar_get32`, `bar_set32`.

-   Implement `cue` and `cap`.

-   Heavy testing.

-   Jet `jar`, `jam`, `cap`, and `cue`.  Heavily test that the jetted
    an unjetted implementations have the same behavior.

-   Actually, don't do this.  Instead, build a second implementation of
    jar/jam for demonstrations purposes.  This implementation should be
    hand-optimized instead of jetted.  It should use a Tab for
    backreferences and to avoid re-processing Jar state.

    `jar2` should serve as a benchmark and as a demonstration that custom
    domain-specific serialization code is possible.


Macro Interface
===============

-   Macros are given the whole rexpression (instead of kids + heir)

-   TODO Datajet Rex

        That WOULD solve the inefficiencies around moving switching
        representations when moving between macro-friendly and
        Haskell-friendly representations.  Should massively speed up
        macro code, and should make rexpression printable in Loot.

        Loot can use this syntax for rexpressions:

            ``(3 + 4)

        Maybe use `,,x` for unquote/embed?

        What if the rex literally includes a `,,` node?

    ```
    0-[t k s]    --  Text
    1-[r t k s]  --  Node
    2-x          --  Embed
    ```

-   TODO Macros should return "new gensym state" instead of gensym
    increment.  It just simpler, don't need to be so defensive here.

-   Give `simpleMacro` and `gensymMacro` a better interface.

    Or better jet, just build better tools for working with syntax,
    and remove these "frameworks".


Macro System
============

-   Command parser should also do macro-expansion.

-   Make it so that macros can over-ride built-in syntax.

-   Make all built-in syntax have a short form `@` and a long form `#@`.
    This way, macro-expansions can target the stable two-character runes
    and be free to redefine the one-character version.

    In particular, we want to replace `*`, `@`, and `?` with versions
    that support pattern matching and destructuring.


Macros
======

-   `*` should support composite patterns

    Rows, tabs, and identifiers are already supported.  Add support for
    combinations of these:

        * [[k v] x %[a b]]
           ,, [3 4]
           ,, 5
           ,, %[a=6 b=7]
        | sum [k v x a b]

-   Pattern Matching (with destructuring)

    Something like this.  Whatever.

        ### x
          = 0            | %Zero
          = 9            | %Nine
          = @x (gte x 3) | mod x 3
          = %[=k]        | k
          = [x y]        | add x y
          = [x y z]      | add x add-y-z
          = (0 x)        | x
          = ~[a b c]     | x
          %fallback

-   Support fancy lambda syntax with LambdaCases and pattern matching.


Runner
======

Port runner over to the new Machine architecture (The runner has no
persistence).

Possible Naming Scheme for Hardware:

-   `0-65535`: Standard hardware (16 bits)
-   `65536-4294967296`: NonStandard Hardware (32 bits)
-   `4294967296-*`: Ephemeral Processes ("file descriptors")


Hardware Console
----------------

The Hardware Console lives at address=0

    data Request a where
        AcceptTerminalConnection :: Text -> Request Handle

Requests to the hardware console block until a new hardware terminal
is connected to the machine.  Then, the address of a new Socket is
returned, and that can be used to communicate between Plunder and the
hardware terminal.

The socket is essentially a telnet connection.

This provides a way for a Plunder processes to support remote-control
via a terminal interface.


Localhost HTTP Server
---------------------

The HTTP Server lives at Hardware=1

```
data Request a where
    HTTPServe  :: Map Text (Text, ByteString) -> Request a
    HTTPListen :: Text -> Request Handle
```

When the server gets a HTTPServe request, it makes the given data structure
available over HTTP.  The request never returns.  If the request is
canceled, the data is no longer served.  If multiple HTTPServe requests
happen simultaneously, both of them are accepted, but hardware will
arbitrarily choose which directory to serve.

When the server gets a HTTPListen request, it begins to accept websocket
requests at "/${key}".  When a websocket request comes in, a new hardware
address is created for that communication.  The new hardware is a simple
socket device with Read/Write requests that work with Bars.

This device is intended to allow Plunder code to build browser interfaces.


Persist
-------

Understand the event log implementation. If it isn't fully working
yet, see if I can help him with that.
